# JavaScript性能优化

## JavaScript内存管理

### 内存管理介绍

- 内存：由可读写单元组成，表示一片可操作空间
- 管理：认为的去操作一片空间的申请、使用和释放
- 内存管理：开发者主动申请空间、使用空间、释放空间
- 管理流程：申请—使用—释放

### JavaScript中的内存管理

- 申请内存空间

	- let obj={}

- 使用内存空间

	- obj.name = 'songxiao'

- 释放内存空间

	- obj = null

### JavaScript中的垃圾回收

- JavaScript 中的垃圾

	- JavaScript 中内存管理是自动的
	- 对象不再被引用时是垃圾
	-  对象不能从跟上访问到时是垃圾

- JavaScript 中的可达对象

	- 可以访问到的对象就是可达对象（引用、作用域链）
	- 可达的标准就是从根上出发能否被找到
	- JavaScript 中的根就可以理解为是全局变量对象

## 垃圾回收与常见GC算法

### GC定义与作用

- GC就是垃圾回收机制的缩写
- GC 可以找到内存中的垃圾、并释放和回收空间

### GC里的垃圾是什么

- 程序中不再需要使用的对象

  - ```javascript
    function func(){
    name = 'lg'
    return `${name} is a coder`
    }
    func()
    ```

- 程序中不能再访问到的对象

  - ```javascript
    function func(){
      const name = 'lg'
      return `${name} is a coder`
    }
    func()
    ```

### GC算法是什么

- GC是一种机制，垃圾回收器完成具体的工作
- 工作的内容就是查找垃圾释放空间、回收空间
- 算法就是工作时查找和回收所遵循的规则

### 常见的GC算法

- 引用计数

	- 算法原理

		- 核心思想：设置引用数，判断当前引用数是否为0
		- 引用计数器
		- 引用关系改变时修改引用数字
		- 引用数字为0时立即回收

	- 优点

		- 可以即时回收垃圾对象
		- 减少程序卡顿时间

	- 缺点

		- 无法回收循环引用的对象
		- 时间开销大，资源开销大

			- 因为引用计数器的存在，效率没有别的算法快

- 标记清除

	- 算法原理

		- 核心思想：分标记和清除二个阶段完成
		- 遍历所有对象找标记活动对象
		- 编辑所有对象清除没有标记对象
		- 回收相应的空间

	- 优点

		-  可以回收循环引用的对象
		- 函数局部内部对象失去了global的连接，成为不可达对象。可以释放这类无标记的对象。

	- 缺点

		- 产生碎片化空间，浪费空间
		- 不会立即回收垃圾对象
		- 由于回收的垃圾对象，在地址上本身是不连续的，不能让空间在最大程度上使用

- 标记整理

	- 算法原理

		- 标记整理可以看作是标记清除的增强
		- 标记阶段的操作和标记清除一致
		- 清除阶段会先执行整理，移动对象位置

	- 优点

		- 减少碎片化空间

	- 缺点

		- 不会立即回收垃圾对象

- 分代回收

## V8引擎的垃圾回收

### V8

- V8 是一款主流的JavaScript执行引擎
- V8 采用即使编译，速度很快
- V8 内存设限

	- 64位 1.5G 32位 800MB
	- 为了浏览器设置的，对于外部应用是足够的
	- 垃圾回收机制

- V8采用基于分代回收思想实现垃圾回收
- V8内存分为新生代和老生代

### V8垃圾回收策略

- 采用分代回收的思想
- 内存分为新生代、老生代
- 针对不用对象采用不同算法

### V8中常用GC算法

- 分代回收
- 空间复制
- 标记清除
- 标记整理
- 标记增量

### V8如何回收新生代对象

- V8 内存分配

	- V8 空间一分为二
	- 小空间用于存储新生代对象（32M｜16M）
	- 新生代指的是存活时间较短的对象

- 新生代对象回收实现

	- 回收过程采用复制算法+标记整理
	- 新生代内存区分为二个等大小空间
	- 使用空间为Form，空间空间为To
	- 活动对象存储于From空间
	- 标记整理后将活动对象拷贝至To
	- 清除Form，并将From 与 To 交换空间完成释放

- 回收细节说明

	- 拷贝过程中可能出现晋升
	- 晋升就是将新生代对象移动至老圣代
	- 一轮GC还存活的新生代需要晋升
	- To 空间的使用率超过 25%

### V8如何回收老生代对象

- 老生代对象说明

	- 老生代对象存放在右侧老生代区域
	- 64位操作系统1.4G，32操作系统700M
	- 老生代对象就是指存活时间较长的对象

- 老生代对象回收实现

	- 主要采用标记清除、标记整理、增量标记算法
	- 首先使用标记清除完成垃圾空间的回收
	- 空间不足，采用标记整理进行空间优化
	- 采用增量标记进行效率优化

### 细节对比

- 新生代区域垃圾回收使用空间换时间
- 老生代区域垃圾回收不适合复制算法

## Performance 工具

### 为什么使用Performance

- GC的目的是为了实现内存空间的良性循环
- 良性循环的基石是合理使用
- 时刻关注才能确认是否合理
- Performance提供多种监控方式

### 通过Performance时刻监控内存

- 使用步骤

	- 打开浏览器输入网址
	- 进入开发人员工具面板，选择性能
	- 开启录制功能，访问具体界面
	- 执行用户行为，一段时间后停止录制
	- 分析界面中记录的内存信息

### 内存问题的体现

- 内存问题的外在表现

	- 页面出现延迟加载或经常性暂停
	- 页面持续性出现糟糕的性能

		- 一瞬间内存爆掉了

	- 页面的性能随时间延长越来越差

		- 内存泄漏

### 监控内存的几种方式

- 界定内存问题的标准

	- 内存泄漏：内存使用持续升高
	- 内存膨胀：在多数设备上都存在性能问题
	- 频繁垃圾回收：通过内存变化图进行分析

- 几种方式

	- 浏览器任务管理器

		- shift+esc
		- 右键显示出Javascript内存
		- 内存（DOM）
		- JavaScript内存（小括号里面的数值表示内存）

	- Timeline时序图记录

		- 性能面板

	- 堆快照查找分离DOM

		- 什么是分离DOM

			- 界面元素存活在DOM树上
			- 垃圾对象时的DOM节点
			- 分离状态的DOM节点

		- 内存面板

			- 快照

				- deta

	- 判断是否存在频繁的垃圾回收

		- 为什么确定频繁垃圾回收

			- GC工作时应用程序是停止的
			- 频繁且过长的GC会导致应用假死
			- 用户使用中感知应用卡顿

		- 确定频繁的垃圾回收

			- Timeline中频繁的上升下降
			- 任务管理器中数据频繁的增加减小

## 代码优化实例

### 代码优化介绍

- 基本信息

	- JavaScript中的内存管理自动完成
	- 执行引擎会使用不同的GC算法
	- 算法工作的目的是为了实现内存空间的良性循环
	- Performance工具检测内存变化
	- JavaScript工具是单线程机制的解释型语言

- 如何精准测试JavaScript性能

	- 本质上就是采集大量的执行压根进行数学统计和分析
	- 使用基于Benchmark.js的https://jsperf.com/完成

- Jsperf使用流程

	- 使用Github账号登录
	- 填写个人信息（非必须）
	- 填写详细的测试用例信息（title、slug）
	- 填写准备代码（DOM操作时经常使用）
	- 填写必要有setup与teardown代码
	- 填写测试代码片段

### 做法/方法

- 慎用全局变量

	- 原因

		- 全局变量定义在全局执行上下文，是所有作用域链的顶端
		- 全局执行上下文一致存在于上下文执行栈，直到程序退出
		- 如果某个局部作用域出现了同名变量则会遮蔽或污染全局

	- 明确数据作用域的情况下，尽量用局部

- 缓存全局变量

	- 将使用中无法避免的全局变量缓存到局部

- 通过原型新增方法

	- 在原型对象上新增实例对象需要的方法

- 避开闭包陷阱

  - 闭包特点

    - 外部具有指向内部的引用
    - 在外部作用域访问部分作用域的数据

      - ```javascript
        function foo(){
          var name = 'lg'
          function fn() {
            console.log(name)
          }
          return fn
        }
        var a = foo()
        a()
        ```

  - 关于闭包

  	- 闭包是一种强大的语法
  	- 闭包使用不当很容易出现内容泄露
  	- 不要为了闭包而闭包

- 避免属性访问方法使用

	- JavaScript 中的面向对象

		- JS不需属性的访问方法，所有属性都是外部可见的
		- 使用属性访问方法只会增加一层重定义，没有访问的控制力

- For 循环优化
- 选择最优的循环方式

	- forEach > for > for in

- 节点添加添加优化

	- 节点的添加操作必然会有回流和重绘
	- 使用文档碎片方式进行节点的添加

- 克隆优化节点操作
- 直接量替换Object操作
